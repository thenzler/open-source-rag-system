<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Project SUSI - Simple Interface</title>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0/css/all.min.css">
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, sans-serif;
            background-color: #f5f5f5;
            color: #333;
        }

        .container {
            max-width: 1200px;
            margin: 0 auto;
            padding: 20px;
        }

        h1 {
            text-align: center;
            color: #2c3e50;
            margin-bottom: 30px;
        }

        .card {
            background: white;
            border-radius: 8px;
            padding: 20px;
            margin-bottom: 20px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
        }

        .upload-section {
            border: 2px dashed #3498db;
            border-radius: 8px;
            padding: 40px;
            text-align: center;
            margin-bottom: 20px;
        }

        .file-input {
            margin: 20px 0;
        }

        .btn {
            background-color: #3498db;
            color: white;
            border: none;
            padding: 12px 24px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 16px;
            transition: background-color 0.3s;
        }

        .btn:hover {
            background-color: #2980b9;
        }

        .btn:disabled {
            background-color: #bdc3c7;
            cursor: not-allowed;
        }

        .search-section {
            margin-top: 20px;
        }

        .search-input {
            width: 100%;
            padding: 12px;
            border: 2px solid #e0e0e0;
            border-radius: 4px;
            font-size: 16px;
            margin-bottom: 10px;
        }

        .search-input:focus {
            outline: none;
            border-color: #3498db;
        }

        .results {
            margin-top: 20px;
        }

        .result-item {
            background: #f8f9fa;
            border-left: 4px solid #3498db;
            padding: 15px;
            margin-bottom: 10px;
            border-radius: 4px;
        }

        .result-title {
            font-weight: bold;
            color: #2c3e50;
            margin-bottom: 5px;
        }

        .result-content {
            color: #666;
            line-height: 1.5;
        }

        .result-score {
            font-size: 12px;
            color: #7f8c8d;
            margin-top: 5px;
        }

        .status {
            padding: 10px;
            border-radius: 4px;
            margin-bottom: 10px;
        }

        .status.success {
            background-color: #d4edda;
            color: #155724;
            border: 1px solid #c3e6cb;
        }

        .status.error {
            background-color: #f8d7da;
            color: #721c24;
            border: 1px solid #f5c6cb;
        }
        
        .status.warning {
            background-color: #fff3cd;
            color: #856404;
            border: 1px solid #ffeaa7;
        }
        
        .status.info {
            background-color: #d1ecf1;
            color: #0c5460;
            border: 1px solid #bee5eb;
        }

        .documents-list {
            margin-top: 20px;
        }

        .document-item {
            background: #f8f9fa;
            padding: 15px;
            margin-bottom: 10px;
            border-radius: 8px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            transition: all 0.3s ease;
            border: 1px solid #e0e0e0;
        }
        
        .document-item:hover {
            background: #e8f4f8;
            border-color: #3498db;
            box-shadow: 0 2px 8px rgba(52, 152, 219, 0.1);
        }
        
        .document-item.deleting {
            opacity: 0.5;
            pointer-events: none;
        }

        .document-info {
            flex: 1;
        }

        .document-name {
            font-weight: bold;
            color: #2c3e50;
        }

        .document-details {
            font-size: 12px;
            color: #7f8c8d;
            margin-top: 4px;
        }
        
        .document-status {
            display: inline-block;
            padding: 2px 8px;
            border-radius: 12px;
            font-size: 11px;
            font-weight: 500;
            margin-left: 8px;
        }
        
        .status-processed {
            background: #d4edda;
            color: #155724;
        }
        
        .status-processing {
            background: #fff3cd;
            color: #856404;
        }
        
        .status-error {
            background: #f8d7da;
            color: #721c24;
        }

        .delete-btn {
            background-color: #e74c3c;
            color: white;
            border: none;
            padding: 5px 10px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 12px;
        }

        .delete-btn:hover {
            background-color: #c0392b;
        }

        .loading {
            text-align: center;
            color: #7f8c8d;
            font-style: italic;
        }
        
        .refresh-btn {
            background-color: #95a5a6;
            color: white;
            border: none;
            padding: 8px 16px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 14px;
            margin-left: 10px;
        }
        
        .refresh-btn:hover {
            background-color: #7f8c8d;
        }
        
        .delete-all-btn {
            background-color: #e74c3c;
            color: white;
            border: none;
            padding: 8px 16px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 14px;
            margin-left: 10px;
        }
        
        .delete-all-btn:hover {
            background-color: #c0392b;
        }
        
        .delete-all-btn:disabled {
            background-color: #bdc3c7;
            cursor: not-allowed;
        }
        
        .storage-info {
            background: #ecf0f1;
            padding: 10px;
            border-radius: 4px;
            margin-bottom: 15px;
            font-size: 13px;
        }
        
        .storage-type {
            font-weight: bold;
            color: #2c3e50;
        }
        
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
        
        .spinner {
            display: inline-block;
            width: 16px;
            height: 16px;
            border: 2px solid #f3f3f3;
            border-top: 2px solid #3498db;
            border-radius: 50%;
            animation: spin 1s linear infinite;
            margin-right: 5px;
        }
        
        @keyframes blink {
            0%, 50% { opacity: 1; }
            51%, 100% { opacity: 0; }
        }
        
        .cursor-blink {
            animation: blink 1s infinite;
            color: #3498db;
            font-weight: bold;
        }
        
        .fast-result {
            border-left: 4px solid #f39c12;
            background: #fff9e6;
        }
        
        .cached-result {
            border-left: 4px solid #27ae60;
            background: #eafaf1;
        }
        
        /* Zero-Hallucination UI Indicators */
        .confidence-meter {
            display: flex;
            align-items: center;
            margin: 10px 0;
            padding: 10px;
            border-radius: 6px;
            font-size: 14px;
        }
        
        .confidence-high {
            background: #d4edda;
            border: 1px solid #c3e6cb;
            color: #155724;
        }
        
        .confidence-medium {
            background: #fff3cd;
            border: 1px solid #ffeaa7;
            color: #856404;
        }
        
        .confidence-low {
            background: #f8d7da;
            border: 1px solid #f5c6cb;
            color: #721c24;
        }
        
        .confidence-bar {
            flex: 1;
            height: 8px;
            background: #e9ecef;
            border-radius: 4px;
            margin: 0 10px;
            overflow: hidden;
        }
        
        .confidence-fill {
            height: 100%;
            transition: width 0.3s ease;
        }
        
        .confidence-fill.high {
            background: linear-gradient(90deg, #28a745, #20c997);
        }
        
        .confidence-fill.medium {
            background: linear-gradient(90deg, #ffc107, #fd7e14);
        }
        
        .confidence-fill.low {
            background: linear-gradient(90deg, #dc3545, #e83e8c);
        }
        
        .zero-hallucination-badge {
            display: inline-block;
            padding: 4px 8px;
            border-radius: 12px;
            font-size: 12px;
            font-weight: bold;
            margin: 0 5px;
        }
        
        .badge-verified {
            background: #d4edda;
            color: #155724;
            border: 1px solid #c3e6cb;
        }
        
        .badge-refused {
            background: #f8d7da;
            color: #721c24;
            border: 1px solid #f5c6cb;
        }
        
        .badge-external-blocked {
            background: #fff3cd;
            color: #856404;
            border: 1px solid #ffeaa7;
        }
        
        .source-transparency {
            background: #f8f9fa;
            border: 1px solid #dee2e6;
            border-radius: 6px;
            padding: 12px;
            margin: 10px 0;
        }
        
        .source-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 8px 0;
            border-bottom: 1px solid #e9ecef;
        }
        
        .source-item:last-child {
            border-bottom: none;
        }
        
        .source-confidence {
            font-weight: bold;
            padding: 2px 6px;
            border-radius: 4px;
            font-size: 11px;
        }
        
        .validation-status {
            margin: 15px 0;
            padding: 12px;
            border-radius: 6px;
            border-left: 4px solid;
        }
        
        .validation-passed {
            background: #d4edda;
            border-left-color: #28a745;
            color: #155724;
        }
        
        .validation-failed {
            background: #f8d7da;
            border-left-color: #dc3545;
            color: #721c24;
        }
        
        .external-knowledge-warning {
            background: #fff3cd;
            border-left-color: #ffc107;
            color: #856404;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>Project SUSI - Smart Universal Search Intelligence</h1>
        
        <!-- Upload Section -->
        <div class="card">
            <h2>üìÅ Upload Documents</h2>
            <div class="upload-section">
                <p>Upload your documents (PDF, Word, Text, CSV)</p>
                <div class="file-input">
                    <input type="file" id="fileInput" accept=".pdf,.docx,.txt,.csv" multiple>
                </div>
                <button class="btn" onclick="uploadFiles()">Upload Documents</button>
            </div>
            <div id="uploadStatus"></div>
        </div>

        <!-- Search Section -->
        <div class="card">
            <h2>üîç Search Documents</h2>
            <div class="search-section">
                <input type="text" class="search-input" id="searchInput" placeholder="Enter your question here..." onkeypress="handleSearchKeyPress(event)">
                
                <div style="margin: 10px 0;">
                    <div style="padding: 8px; background: #e8f5e8; border-radius: 4px; color: #2c5530;">
                        ü§ñ <strong>AI Answers Only</strong> - Professional zero-hallucination responses with source citations
                    </div>
                </div>
                
                <div style="display: flex; gap: 10px;">
                    <button class="btn" onclick="searchDocuments()">Search</button>
                    <button class="btn" onclick="checkSystemStatus()" style="background-color: #27ae60;">Check System Status</button>
                </div>
            </div>
            <div id="systemStatus"></div>
            <div id="searchResults"></div>
        </div>

        <!-- Documents List -->
        <div class="card">
            <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 20px;">
                <h2>üìÑ Uploaded Documents</h2>
                <div>
                    <span id="documentCount" style="color: #7f8c8d; margin-right: 10px;"></span>
                    <button class="refresh-btn" onclick="refreshDocuments()" title="Refresh document list">
                        üîÑ Refresh
                    </button>
                    <button class="delete-all-btn" onclick="deleteAllDocuments()" title="Delete all documents">
                        üóëÔ∏è Delete All
                    </button>
                </div>
            </div>
            <div id="storageInfo" class="storage-info" style="display: none;"></div>
            <div id="documentsList"></div>
        </div>
    </div>

    <script>
        const API_BASE = 'http://localhost:8002';

        // Upload files
        async function uploadFiles() {
            const fileInput = document.getElementById('fileInput');
            const files = fileInput.files;
            const statusDiv = document.getElementById('uploadStatus');
            
            if (files.length === 0) {
                showStatus('Please select files to upload', 'error');
                return;
            }

            let successCount = 0;
            let errorCount = 0;
            statusDiv.innerHTML = `<div class="loading"><span class="spinner"></span>Uploading ${files.length} document${files.length > 1 ? 's' : ''}...</div>`;

            for (let i = 0; i < files.length; i++) {
                const file = files[i];
                const formData = new FormData();
                formData.append('file', file);

                try {
                    const response = await fetch(`${API_BASE}/api/v1/documents`, {
                        method: 'POST',
                        body: formData
                    });

                    const result = await response.json();
                    
                    if (response.ok) {
                        if (result.status === 'duplicate') {
                            showStatus(`‚ö†Ô∏è ${file.name} already exists (skipped)`, 'warning');
                        } else {
                            showStatus(`‚úì ${file.name} uploaded successfully`, 'success');
                            successCount++;
                        }
                    } else {
                        showStatus(`‚úó Error uploading ${file.name}: ${result.detail}`, 'error');
                        errorCount++;
                    }
                } catch (error) {
                    showStatus(`‚úó Error uploading ${file.name}: ${error.message}`, 'error');
                    errorCount++;
                }
            }

            // Show summary
            if (successCount > 0 || errorCount > 0) {
                const summary = `Upload complete: ${successCount} succeeded, ${errorCount} failed`;
                showStatus(summary, errorCount > 0 ? 'warning' : 'success');
            }

            // Refresh documents list after a short delay
            setTimeout(() => {
                loadDocuments();
            }, 500);
            
            // Clear file input
            fileInput.value = '';
        }

        // Search documents - AI answers only
        async function searchDocuments() {
            const searchInput = document.getElementById('searchInput');
            const query = searchInput.value.trim();
            const resultsDiv = document.getElementById('searchResults');
            
            if (!query) {
                showSearchResults('Please enter a search query', 'error');
                return;
            }
            
            resultsDiv.innerHTML = `<div class="loading"><span class="spinner"></span>ü§ñ Generating AI answer with source citations...</div>`;

            try {
                const response = await fetch(`${API_BASE}/api/v1/query`, {
                    method: 'POST',  
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({
                        query: query
                    })
                });

                const result = await response.json();
                
                if (response.ok) {
                    displaySimpleRAGResults(result);
                } else {
                    showSearchResults(`Error: ${result.detail}`, 'error');
                }
            } catch (error) {
                showSearchResults(`Error: ${error.message}`, 'error');
            }
        }
        
        // Handle streaming search with real-time updates
        async function handleStreamingSearch(query, resultsDiv) {
            try {
                resultsDiv.innerHTML = `
                    <div class="loading">
                        <span class="spinner"></span>‚ö° Starting real-time AI generation...
                    </div>
                `;
                
                const response = await fetch(`${API_BASE}/api/v1/query-stream`, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({
                        query: query,
                        top_k: 5,
                        use_llm: true
                    })
                });

                if (!response.ok) {
                    throw new Error(`HTTP ${response.status}: ${response.statusText}`);
                }

                const reader = response.body.getReader();
                const decoder = new TextDecoder();
                
                let sources = [];
                let answerText = '';
                let method = 'streaming';
                
                // Create the streaming UI
                resultsDiv.innerHTML = `
                    <div class="results">
                        <div style="color: #2c3e50; font-weight: bold; margin-bottom: 10px;">‚ö° Streaming AI Answer</div>
                        <div style="background: #f8f9fa; padding: 20px; border-radius: 8px; margin-bottom: 20px; border-left: 4px solid #3498db;">
                            <h3 style="margin: 0 0 10px 0; color: #2c3e50;">Answer for: "${query}"</h3>
                            <div id="streamingAnswer" style="line-height: 1.6; color: #333; white-space: pre-wrap; min-height: 50px;">
                                <span class="spinner" style="margin-right: 10px;"></span>Starting generation...
                            </div>
                        </div>
                        <div id="streamingSources" style="display: none;">
                            <h4>üìö Sources</h4>
                            <div id="sourcesContainer"></div>
                        </div>
                    </div>
                `;
                
                const answerDiv = document.getElementById('streamingAnswer');
                const sourcesDiv = document.getElementById('streamingSources');
                const sourcesContainer = document.getElementById('sourcesContainer');
                
                while (true) {
                    const { done, value } = await reader.read();
                    
                    if (done) break;
                    
                    const chunk = decoder.decode(value, { stream: true });
                    const lines = chunk.split('\n');
                    
                    for (const line of lines) {
                        if (line.startsWith('data: ')) {
                            try {
                                const data = JSON.parse(line.slice(6));
                                
                                if (data.type === 'metadata') {
                                    sources = data.sources;
                                    // Show sources immediately
                                    if (sources && sources.length > 0) {
                                        sourcesDiv.style.display = 'block';
                                        displayStreamingSources(sources, sourcesContainer);
                                    }
                                } else if (data.type === 'answer_start') {
                                    answerDiv.innerHTML = '';
                                    answerText = '';
                                } else if (data.type === 'answer_chunk') {
                                    answerText += data.content;
                                    answerDiv.innerHTML = answerText + '<span class="cursor-blink">|</span>';
                                    // Auto-scroll to bottom
                                    answerDiv.scrollTop = answerDiv.scrollHeight;
                                } else if (data.type === 'answer_complete') {
                                    answerText = data.content;
                                    method = data.method;
                                    answerDiv.innerHTML = answerText;
                                } else if (data.type === 'answer_end') {
                                    method = data.method;
                                    answerDiv.innerHTML = answerText;
                                } else if (data.type === 'done') {
                                    // Remove blinking cursor
                                    answerDiv.innerHTML = answerText;
                                    break;
                                } else if (data.error) {
                                    throw new Error(data.error);
                                }
                            } catch (parseError) {
                                console.warn('Failed to parse SSE data:', parseError);
                            }
                        }
                    }
                }
                
            } catch (error) {
                console.error('Streaming error:', error);
                resultsDiv.innerHTML = `
                    <div class="status error">
                        Streaming failed: ${error.message}<br>
                        <button onclick="searchDocuments()" style="margin-top: 10px; background: #3498db; color: white; border: none; padding: 8px 16px; border-radius: 4px; cursor: pointer;">
                            Try Standard Search
                        </button>
                    </div>
                `;
            }
        }
        
        // Handle LLM-only search (no document context)
        async function handleLLMOnlySearch(query, resultsDiv) {
            try {
                resultsDiv.innerHTML = `<div class="loading"><span class="spinner"></span>üß† Generating LLM response without document context...</div>`;
                
                const response = await fetch(`${API_BASE}/api/v1/query/llm-only`, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({
                        query: query
                    })
                });

                const result = await response.json();
                
                if (response.ok) {
                    displayLLMOnlyResults(result);
                } else {
                    showSearchResults(`Error: ${result.detail}`, 'error');
                }
            } catch (error) {
                showSearchResults(`Error: ${error.message}`, 'error');
            }
        }
        
        // Display LLM-only results
        function displayLLMOnlyResults(result) {
            const resultsDiv = document.getElementById('searchResults');
            
            let html = '<div class="results">';
            
            // Method indicator
            html += `<div style="color: #2c3e50; font-weight: bold; margin-bottom: 10px;">üß† Pure LLM Response (No Document Context)</div>`;
            
            // Show processing time
            if (result.processing_time) {
                html += `<div style="color: #7f8c8d; font-size: 12px; margin-bottom: 15px;">
                    Processing time: ${result.processing_time.toFixed(2)}s
                </div>`;
            }
            
            // Main answer
            const answerText = result.response || result.answer || 'No answer available';
            const queryText = result.query || 'Unknown query';
            
            html += `<div style="background: #f1f8ff; padding: 20px; border-radius: 8px; margin-bottom: 20px; border-left: 4px solid #007bff;">
                <h3 style="margin: 0 0 10px 0; color: #2c3e50;">Pure LLM Answer for: "${queryText}"</h3>
                <div style="line-height: 1.6; color: #333; white-space: pre-wrap;">${answerText}</div>
            </div>`;
            
            // Add note about no document context
            html += `<div style="background: #fff3cd; border: 1px solid #ffeaa7; padding: 15px; border-radius: 6px; margin-top: 15px;">
                <h4 style="margin: 0 0 8px 0; color: #856404;">‚ÑπÔ∏è Note about LLM-Only Mode</h4>
                <p style="margin: 0; color: #856404; font-size: 14px;">
                    This response was generated using the <strong>arlesheim-german</strong> model without any document context. 
                    The model is responding based on its training data and built-in knowledge about Arlesheim municipality.
                    For document-specific questions, use "AI Generated Answer (with document context)" mode instead.
                </p>
            </div>`;
            
            html += '</div>';
            resultsDiv.innerHTML = html;
        }
        
        // Display sources during streaming
        function displayStreamingSources(sources, container) {
            let html = '';
            sources.forEach((source, index) => {
                const similarity = source.similarity_score || source.score || 0;
                html += `
                    <div class="result-item" style="margin-bottom: 10px; border: 1px solid #e9ecef; border-radius: 6px; padding: 12px; opacity: 0.8;">
                        <div class="result-title" style="font-weight: 600; color: #2c3e50; margin-bottom: 6px;">üìÑ ${source.source_document}</div>
                        <div class="result-content" style="line-height: 1.4; color: #666; font-size: 13px; margin-bottom: 6px;">${source.content.substring(0, 200)}${source.content.length > 200 ? '...' : ''}</div>
                        <div class="result-score" style="font-size: 11px; color: #7f8c8d;">Similarity: ${(similarity * 100).toFixed(1)}%</div>
                    </div>
                `;
            });
            container.innerHTML = html;
        }

        // Display search results (legacy vector search)
        function displaySearchResults(result) {
            const resultsDiv = document.getElementById('searchResults');
            
            if (result.results.length === 0) {
                resultsDiv.innerHTML = '<div class="status">No results found for your query.</div>';
                return;
            }

            let html = '<div class="results">';
            html += `<h3>üìÑ Found ${result.total_results} document chunks for "${result.query}"</h3>`;
            
            result.results.forEach(item => {
                html += `
                    <div class="result-item">
                        <div class="result-title">üìÑ ${item.source_document}</div>
                        <div class="result-content">${item.content}</div>
                        <div class="result-score">Similarity: ${(item.score * 100).toFixed(1)}%</div>
                    </div>
                `;
            });
            
            html += '</div>';
            resultsDiv.innerHTML = html;
        }

        // Extract key phrases from answer for highlighting
        function extractAnswerPhrases(answerText) {
            // Remove source references and clean text
            const cleanAnswer = answerText.replace(/\n\nQuelle:.*$/g, '').trim();
            
            // Split into sentences and extract meaningful phrases
            const sentences = cleanAnswer.split(/[.!?]+/).filter(s => s.trim().length > 0);
            const phrases = [];
            
            sentences.forEach(sentence => {
                // Extract key noun phrases (simple approach)
                const words = sentence.trim().split(/\s+/);
                
                // Extract 2-4 word phrases
                for (let i = 0; i < words.length - 1; i++) {
                    for (let len = 2; len <= Math.min(4, words.length - i); len++) {
                        const phrase = words.slice(i, i + len).join(' ');
                        if (phrase.length > 5 && !phrase.match(/^(der|die|das|ein|eine|und|oder|f√ºr|in|an|auf|mit|von|zu|ist|sind|werden|wird)$/i)) {
                            phrases.push(phrase.toLowerCase());
                        }
                    }
                }
                
                // Also add individual important words (longer than 4 chars)
                words.forEach(word => {
                    const cleanWord = word.replace(/[.,!?;:"']/g, '').toLowerCase();
                    if (cleanWord.length > 4 && !cleanWord.match(/^(aber|auch|dann|dass|diese|einem|einer|eines|haben|nicht|noch|oder|sind|√ºber|unter|werden|wird|wurde|wurden)$/)) {
                        phrases.push(cleanWord);
                    }
                });
            });
            
            // Remove duplicates and sort by length (longer phrases first)
            return [...new Set(phrases)].sort((a, b) => b.length - a.length);
        }

        // Highlight text based on phrases
        function highlightText(text, phrases) {
            let highlightedText = text;
            
            phrases.forEach(phrase => {
                // Create case-insensitive regex
                const regex = new RegExp(`(${phrase.replace(/[.*+?^${}()|[\]\\]/g, '\\$&')})`, 'gi');
                highlightedText = highlightedText.replace(regex, '<mark style="background-color: #fff3cd; padding: 1px 2px; border-radius: 2px; font-weight: 500;">$1</mark>');
            });
            
            return highlightedText;
        }

        // Zero-Hallucination UI Helper Functions
        function createZeroHallucinationIndicators(result) {
            let html = '';
            
            // Zero-Hallucination status badges
            html += '<div style="margin: 10px 0;">';
            
            // Overall zero-hallucination status
            if (result.refusal_reason) {
                if (result.refusal_reason.includes('externes Wissen')) {
                    html += '<span class="zero-hallucination-badge badge-external-blocked">üö´ External Knowledge Blocked</span>';
                } else {
                    html += '<span class="zero-hallucination-badge badge-refused">‚ùå Low Confidence Refused</span>';
                }
            } else if (result.validation_passed) {
                html += '<span class="zero-hallucination-badge badge-verified">‚úÖ Response Verified</span>';
            } else if (result.validation_failed) {
                html += '<span class="zero-hallucination-badge badge-refused">‚ö†Ô∏è Validation Failed</span>';
            } else {
                html += '<span class="zero-hallucination-badge badge-verified">‚úì Zero-Hallucination Protected</span>';
            }
            
            html += '</div>';
            
            // Confidence meter (if available)
            const confidence = result.confidence || result.validation_confidence || 0;
            if (confidence > 0) {
                html += createConfidenceMeter(confidence);
            }
            
            // Validation status details (if available)
            if (result.validation_passed === true || result.validation_failed === true) {
                html += createValidationStatus(result);
            }
            
            return html;
        }
        
        function createConfidenceMeter(confidence) {
            const percentage = Math.round(confidence * 100);
            let confidenceClass, confidenceText, confidenceLevel;
            
            if (confidence >= 0.8) {
                confidenceClass = 'confidence-high';
                confidenceLevel = 'high';
                confidenceText = 'High Confidence';
            } else if (confidence >= 0.5) {
                confidenceClass = 'confidence-medium';
                confidenceLevel = 'medium';
                confidenceText = 'Medium Confidence';
            } else {
                confidenceClass = 'confidence-low';
                confidenceLevel = 'low';
                confidenceText = 'Low Confidence';
            }
            
            return `
                <div class="confidence-meter ${confidenceClass}">
                    <span style="font-weight: bold;">üéØ ${confidenceText}</span>
                    <div class="confidence-bar">
                        <div class="confidence-fill ${confidenceLevel}" style="width: ${percentage}%;"></div>
                    </div>
                    <span style="font-weight: bold;">${percentage}%</span>
                </div>
            `;
        }
        
        function createValidationStatus(result) {
            let statusClass, statusIcon, statusText;
            
            if (result.validation_passed) {
                statusClass = 'validation-passed';
                statusIcon = '‚úÖ';
                statusText = 'Response validated against source documents';
                
                if (result.validation_confidence) {
                    statusText += ` (Content similarity: ${(result.validation_confidence * 100).toFixed(1)}%)`;
                }
            } else if (result.validation_failed) {
                statusClass = 'validation-failed';
                statusIcon = '‚ùå';
                statusText = 'Response validation failed';
                
                if (result.validation_reason) {
                    statusText += `: ${result.validation_reason}`;
                }
            } else {
                return '';
            }
            
            return `
                <div class="validation-status ${statusClass}">
                    <strong>${statusIcon} Validation Status:</strong> ${statusText}
                </div>
            `;
        }
        
        function createRefusalDisplay(result) {
            let html = '';
            
            // Main refusal message
            if (result.refusal_reason.includes('externes Wissen')) {
                html += `
                    <div class="external-knowledge-warning validation-status">
                        <strong>üö´ External Knowledge Query Blocked</strong><br>
                        ${result.refusal_reason}
                    </div>
                `;
            } else {
                html += `
                    <div class="validation-status validation-failed">
                        <strong>‚ùå Query Refused - Insufficient Confidence</strong><br>
                        ${result.refusal_reason}
                    </div>
                `;
                
                // Show confidence details if available
                if (result.max_similarity !== undefined && result.confidence_threshold !== undefined) {
                    html += `
                        <div class="source-transparency">
                            <h4>üìä Confidence Analysis</h4>
                            <div class="source-item">
                                <span>Maximum similarity found:</span>
                                <span class="source-confidence" style="background: #f8d7da; color: #721c24;">
                                    ${(result.max_similarity * 100).toFixed(1)}%
                                </span>
                            </div>
                            <div class="source-item">
                                <span>Required threshold:</span>
                                <span class="source-confidence" style="background: #d4edda; color: #155724;">
                                    ${(result.confidence_threshold * 100).toFixed(0)}%
                                </span>
                            </div>
                            <p style="margin-top: 10px; font-size: 13px; color: #666;">
                                üõ°Ô∏è This query was refused to prevent hallucination. No documents were found with sufficient confidence to provide a reliable answer.
                            </p>
                        </div>
                    `;
                }
            }
            
            return html;
        }
        
        function createSourceTransparency(sources) {
            if (!sources || sources.length === 0) return '';
            
            let html = `
                <div class="source-transparency">
                    <h4>üìä Source Confidence Breakdown</h4>
            `;
            
            sources.forEach((source, index) => {
                const similarity = source.similarity || source.similarity_score || source.score || 0;
                const percentage = Math.round(similarity * 100);
                let confidenceColor = '#721c24';
                let confidenceBg = '#f8d7da';
                
                if (similarity >= 0.8) {
                    confidenceColor = '#155724';
                    confidenceBg = '#d4edda';
                } else if (similarity >= 0.5) {
                    confidenceColor = '#856404';
                    confidenceBg = '#fff3cd';
                }
                
                html += `
                    <div class="source-item">
                        <span>üìÑ ${source.source_document || source.document_id || `Source ${index + 1}`}</span>
                        <span class="source-confidence" style="background: ${confidenceBg}; color: ${confidenceColor};">
                            ${percentage}%
                        </span>
                    </div>
                `;
            });
            
            html += `
                    <p style="margin-top: 10px; font-size: 12px; color: #666;">
                        üéØ Only sources above 80% confidence are used for generating answers.
                    </p>
                </div>
            `;
            
            return html;
        }

        // Display SimpleRAG results (from SimpleRAGService)
        function displaySimpleRAGResults(result) {
            const resultsDiv = document.getElementById('searchResults');
            
            let html = '<div class="results">';
            
            // Method indicator
            const methodText = {
                'llm_generated': 'ü§ñ AI Generated Answer',
                'vector_search': 'üìÑ Document Search Results',
                'vector_search_fallback': 'üìÑ Document Search (LLM unavailable)',
                'no_documents': '‚ö†Ô∏è No Documents',
                'no_results': '‚ùå No Results'
            };
            
            const method = methodText[result.method] || result.method || 'ü§ñ AI Generated Answer';
            html += `<div style="color: #2c3e50; font-weight: bold; margin-bottom: 10px;">${method}</div>`;
            
            // Zero-Hallucination Status Indicators
            html += createZeroHallucinationIndicators(result);
            
            // Show processing time
            if (result.processing_time) {
                html += `<div style="color: #7f8c8d; font-size: 12px; margin-bottom: 15px;">
                    Processing time: ${result.processing_time.toFixed(2)}s
                </div>`;
            }
            
            // Handle refusal cases
            if (result.refusal_reason) {
                html += createRefusalDisplay(result);
                html += '</div>';
                resultsDiv.innerHTML = html;
                return;
            }
            
            // Main answer
            const answerText = result.response || result.answer || 'No answer available';
            const queryText = result.query || 'Unknown query';
            
            // Extract phrases from answer for highlighting
            const answerPhrases = extractAnswerPhrases(answerText);
            
            html += `<div style="background: #f8f9fa; padding: 20px; border-radius: 8px; margin-bottom: 20px; border-left: 4px solid #3498db;">
                <h3 style="margin: 0 0 10px 0; color: #2c3e50;">Answer for: "${queryText}"</h3>
                <div style="line-height: 1.6; color: #333; white-space: pre-wrap;">${answerText}</div>
            </div>`;
            
            // Sources with highlighting and transparency
            const sources = result.context || result.sources || [];
            if (sources && sources.length > 0) {
                // Source transparency section
                html += createSourceTransparency(sources);
                
                html += `<h4>üìö Sources (${sources.length}) - <span style="color: #f39c12; font-size: 14px;">üîç Highlighted text shows what was used in the answer</span></h4>`;
                sources.forEach((source, index) => {
                    const similarity = source.similarity_score || source.score || 0;
                    
                    // Highlight the source content based on answer phrases
                    const highlightedContent = highlightText(source.content, answerPhrases);
                    
                    // Color-code border based on confidence
                    let borderColor = '#e9ecef';
                    if (similarity >= 0.8) {
                        borderColor = '#28a745';
                    } else if (similarity >= 0.5) {
                        borderColor = '#ffc107';
                    } else {
                        borderColor = '#dc3545';
                    }
                    
                    html += `
                        <div class="result-item" style="margin-bottom: 15px; border: 2px solid ${borderColor}; border-radius: 8px; padding: 15px;">
                            <div class="result-title" style="font-weight: 600; color: #2c3e50; margin-bottom: 8px;">üìÑ ${source.source_document}</div>
                            <div class="result-content" style="line-height: 1.6; color: #333; margin-bottom: 8px;">${highlightedContent}</div>
                            <div style="display: flex; justify-content: space-between; align-items: center;">
                                <div class="result-score" style="font-size: 12px; color: #7f8c8d;">Similarity: ${(similarity * 100).toFixed(1)}%</div>
                                ${similarity >= 0.8 ? '<span style="color: #28a745; font-size: 12px; font-weight: bold;">‚úÖ High Confidence</span>' : 
                                  similarity >= 0.5 ? '<span style="color: #ffc107; font-size: 12px; font-weight: bold;">‚ö†Ô∏è Medium Confidence</span>' : 
                                  '<span style="color: #dc3545; font-size: 12px; font-weight: bold;">‚ùå Low Confidence</span>'}
                            </div>
                        </div>
                    `;
                });
                
                // Add legend
                html += `<div style="background: #e8f4f8; padding: 10px; border-radius: 6px; font-size: 12px; color: #2c3e50; margin-top: 10px;">
                    <strong>üí° How to read this:</strong> Highlighted text shows the specific parts of documents that were used to construct your answer. Border colors indicate confidence: 
                    <span style="color: #28a745; font-weight: bold;">Green (High ‚â•80%)</span>, 
                    <span style="color: #ffc107; font-weight: bold;">Yellow (Medium ‚â•50%)</span>, 
                    <span style="color: #dc3545; font-weight: bold;">Red (Low <50%)</span>
                </div>`;
            }
            
            html += '</div>';
            resultsDiv.innerHTML = html;
        }

        // Display enhanced results (LLM generated)
        function displayEnhancedResults(result) {
            const resultsDiv = document.getElementById('searchResults');
            
            let html = '<div class="results">';
            
            // Method indicator
            const methodText = {
                'llm_generated': 'ü§ñ AI Generated Answer',
                'vector_search': 'üìÑ Document Search Results',
                'vector_search_fallback': 'üìÑ Document Search (LLM unavailable)',
                'no_documents': '‚ö†Ô∏è No Documents',
                'no_results': '‚ùå No Results'
            };
            
            const method = methodText[result.method] || result.method;
            html += `<div style="color: #2c3e50; font-weight: bold; margin-bottom: 10px;">${method}</div>`;
            
            // Zero-Hallucination Status Indicators
            html += createZeroHallucinationIndicators(result);
            
            // Show processing time
            if (result.processing_time) {
                html += `<div style="color: #7f8c8d; font-size: 12px; margin-bottom: 15px;">
                    Processing time: ${result.processing_time.toFixed(2)}s
                </div>`;
            }
            
            // Handle refusal cases
            if (result.refusal_reason) {
                html += createRefusalDisplay(result);
                html += '</div>';
                resultsDiv.innerHTML = html;
                return;
            }
            
            // Main answer
            const answerText = result.response || result.answer || 'No answer available';
            const queryText = result.query || 'Unknown query';
            
            // Extract phrases from answer for highlighting
            const answerPhrases = extractAnswerPhrases(answerText);
            
            html += `<div style="background: #f8f9fa; padding: 20px; border-radius: 8px; margin-bottom: 20px; border-left: 4px solid #3498db;">
                <h3 style="margin: 0 0 10px 0; color: #2c3e50;">Answer for: "${queryText}"</h3>
                <div style="line-height: 1.6; color: #333; white-space: pre-wrap;">${answerText}</div>
            </div>`;
            
            // Sources with highlighting and transparency
            const sources = result.context || result.sources || [];
            if (sources && sources.length > 0) {
                // Source transparency section
                html += createSourceTransparency(sources);
                
                html += `<h4>üìö Sources (${sources.length}) - <span style="color: #f39c12; font-size: 14px;">üîç Highlighted text shows what was used in the answer</span></h4>`;
                sources.forEach((source, index) => {
                    const similarity = source.similarity_score || source.score || 0;
                    
                    // Highlight the source content based on answer phrases
                    const highlightedContent = highlightText(source.content, answerPhrases);
                    
                    // Color-code border based on confidence
                    let borderColor = '#e9ecef';
                    if (similarity >= 0.8) {
                        borderColor = '#28a745';
                    } else if (similarity >= 0.5) {
                        borderColor = '#ffc107';
                    } else {
                        borderColor = '#dc3545';
                    }
                    
                    html += `
                        <div class="result-item" style="margin-bottom: 15px; border: 2px solid ${borderColor}; border-radius: 8px; padding: 15px;">
                            <div class="result-title" style="font-weight: 600; color: #2c3e50; margin-bottom: 8px;">üìÑ ${source.source_document}</div>
                            <div class="result-content" style="line-height: 1.6; color: #333; margin-bottom: 8px;">${highlightedContent}</div>
                            <div style="display: flex; justify-content: space-between; align-items: center;">
                                <div class="result-score" style="font-size: 12px; color: #7f8c8d;">Similarity: ${(similarity * 100).toFixed(1)}%</div>
                                ${similarity >= 0.8 ? '<span style="color: #28a745; font-size: 12px; font-weight: bold;">‚úÖ High Confidence</span>' : 
                                  similarity >= 0.5 ? '<span style="color: #ffc107; font-size: 12px; font-weight: bold;">‚ö†Ô∏è Medium Confidence</span>' : 
                                  '<span style="color: #dc3545; font-size: 12px; font-weight: bold;">‚ùå Low Confidence</span>'}
                            </div>
                        </div>
                    `;
                });
                
                // Add legend
                html += `<div style="background: #e8f4f8; padding: 10px; border-radius: 6px; font-size: 12px; color: #2c3e50; margin-top: 10px;">
                    <strong>üí° How to read this:</strong> Highlighted text shows the specific parts of documents that were used to construct your answer. Border colors indicate confidence: 
                    <span style="color: #28a745; font-weight: bold;">Green (High ‚â•80%)</span>, 
                    <span style="color: #ffc107; font-weight: bold;">Yellow (Medium ‚â•50%)</span>, 
                    <span style="color: #dc3545; font-weight: bold;">Red (Low <50%)</span>
                </div>`;
            }
            
            html += '</div>';
            resultsDiv.innerHTML = html;
        }

        // Check system status
        async function checkSystemStatus() {
            const statusDiv = document.getElementById('systemStatus');
            statusDiv.innerHTML = '<div class="loading">Checking system status...</div>';
            
            try {
                const response = await fetch(`${API_BASE}/api/v1/status`);
                const status = await response.json();
                
                if (response.ok) {
                    displaySystemStatus(status);
                } else {
                    statusDiv.innerHTML = '<div class="status error">Error checking system status</div>';
                }
            } catch (error) {
                statusDiv.innerHTML = `<div class="status error">Error: ${error.message}</div>`;
            }
        }

        // Display system status
        function displaySystemStatus(status) {
            const statusDiv = document.getElementById('systemStatus');
            
            let html = '<div style="background: #f8f9fa; padding: 15px; border-radius: 8px; margin-bottom: 15px;">';
            html += '<h4 style="margin: 0 0 10px 0;">üîß System Status</h4>';
            
            // Overall status
            const statusColor = status.status === 'healthy' ? '#27ae60' : '#e74c3c';
            html += `<div style="color: ${statusColor}; font-weight: bold; margin-bottom: 10px;">Status: ${status.status.toUpperCase()}</div>`;
            
            // Storage information
            if (status.storage) {
                html += '<div style="margin: 10px 0;"><strong>Storage:</strong></div>';
                html += '<ul style="margin: 5px 0 0 20px; font-size: 13px;">';
                if (status.features.persistent_storage) {
                    html += '<li>Type: <span style="color: #27ae60; font-weight: bold;">Persistent Storage (SQLite)</span></li>';
                } else if (status.features.memory_safe_storage) {
                    html += '<li>Type: <span style="color: #f39c12; font-weight: bold;">Memory-Safe Storage</span></li>';
                } else {
                    html += '<li>Type: <span style="color: #e74c3c; font-weight: bold;">Legacy In-Memory</span></li>';
                }
                if (status.storage.usage_percentage_docs !== undefined) {
                    html += `<li>Document Capacity: ${status.storage.usage_percentage_docs}% used</li>`;
                    html += `<li>Chunk Capacity: ${status.storage.usage_percentage_chunks}% used</li>`;
                }
                html += '</ul>';
                
                if (status.storage_warning) {
                    html += `<div style="background: #fff3cd; color: #856404; padding: 8px; border-radius: 4px; margin-top: 10px; font-size: 13px;">‚ö†Ô∏è ${status.storage_warning}</div>`;
                }
            }
            
            // Features grid
            html += '<div style="margin: 15px 0;"><strong>System Features:</strong></div>';
            html += '<div style="display: grid; grid-template-columns: repeat(2, 1fr); gap: 8px; font-size: 13px;">';
            
            const features = [
                { name: 'Vector Search', key: 'vector_search', icon: 'üîç' },
                { name: 'LLM Generation', key: 'llm_generation', icon: 'ü§ñ' },
                { name: 'Document Processing', key: 'document_processing', icon: 'üìÑ' },
                { name: 'FAISS Search', key: 'faiss_search', icon: '‚ö°' },
                { name: 'Async Processing', key: 'async_processing', icon: 'üîÑ' },
                { name: 'Smart Answers', key: 'smart_answers', icon: 'üß†' }
            ];
            
            features.forEach(feature => {
                const isEnabled = status.features[feature.key];
                const bgColor = isEnabled ? '#d4edda' : '#f8d7da';
                const textColor = isEnabled ? '#155724' : '#721c24';
                const statusIcon = isEnabled ? '‚úÖ' : '‚ùå';
                html += `<div style="background: ${bgColor}; color: ${textColor}; padding: 6px 10px; border-radius: 4px; display: flex; align-items: center;">`;
                html += `<span style="margin-right: 5px;">${feature.icon}</span>`;
                html += `<span style="flex: 1;">${feature.name}</span>`;
                html += `<span>${statusIcon}</span>`;
                html += '</div>';
            });
            html += '</div>';
            
            // Statistics with better formatting
            html += '<div style="margin: 15px 0;"><strong>Database Statistics:</strong></div>';
            html += '<div style="background: #ecf0f1; padding: 10px; border-radius: 4px;">';
            html += '<div style="display: grid; grid-template-columns: repeat(3, 1fr); gap: 10px; text-align: center;">';
            html += `<div><div style="font-size: 24px; font-weight: bold; color: #2c3e50;">${status.statistics.documents_uploaded}</div><div style="font-size: 12px; color: #7f8c8d;">Documents</div></div>`;
            html += `<div><div style="font-size: 24px; font-weight: bold; color: #2c3e50;">${status.statistics.total_chunks}</div><div style="font-size: 12px; color: #7f8c8d;">Text Chunks</div></div>`;
            html += `<div><div style="font-size: 24px; font-weight: bold; color: #2c3e50;">${status.statistics.embeddings_created}</div><div style="font-size: 12px; color: #7f8c8d;">Embeddings</div></div>`;
            html += '</div>';
            html += '</div>';
            
            // Ollama status with better styling and controls
            if (status.ollama) {
                html += '<div style="margin: 15px 0;"><strong>ü§ñ Ollama LLM Status:</strong></div>';
                if (status.ollama.available) {
                    html += '<div style="background: #d4edda; color: #155724; padding: 10px; border-radius: 4px;">';
                    html += `<div style="font-weight: bold;">‚úÖ Connected</div>`;
                    html += `<div style="font-size: 13px; margin-top: 4px;">Model: ${status.ollama.model || 'Default'}</div>`;
                    if (status.ollama.response_time) {
                        html += `<div style="font-size: 12px; color: #155724;">Response time: ${status.ollama.response_time}ms</div>`;
                    }
                    html += '<div style="margin-top: 8px;">';
                    html += '<button onclick="preloadLLM()" style="background: #28a745; color: white; border: none; padding: 4px 8px; border-radius: 3px; font-size: 12px; margin-right: 5px; cursor: pointer;">‚ö° Preload</button>';
                    html += '<button onclick="showModelSelector()" style="background: #007bff; color: white; border: none; padding: 4px 8px; border-radius: 3px; font-size: 12px; margin-right: 5px; cursor: pointer;">üîÑ Switch Model</button>';
                    html += '<button onclick="reloadLLMConfig()" style="background: #6c757d; color: white; border: none; padding: 4px 8px; border-radius: 3px; font-size: 12px; cursor: pointer;">üîÑ Reload Config</button>';
                    html += '</div>';
                    html += '</div>';
                } else {
                    html += '<div style="background: #f8d7da; color: #721c24; padding: 10px; border-radius: 4px;">';
                    html += '<div style="font-weight: bold;">‚ùå Not Available</div>';
                    html += `<div style="font-size: 13px; margin-top: 4px;">${status.ollama.error || 'Ollama service is not running'}</div>`;
                    html += '<div style="font-size: 12px; margin-top: 8px;">To enable AI features, start Ollama with: <code style="background: #e0e0e0; padding: 2px 4px; border-radius: 2px;">ollama serve</code></div>';
                    html += '<div style="margin-top: 8px;">';
                    html += '<button onclick="reconnectLLM()" style="background: #dc3545; color: white; border: none; padding: 4px 8px; border-radius: 3px; font-size: 12px; cursor: pointer;">üîÑ Reconnect</button>';
                    html += '</div>';
                    html += '</div>';
                }
            }
            
            html += `<div style="font-size: 11px; color: #7f8c8d; margin-top: 15px; text-align: right;">Last updated: ${new Date().toLocaleTimeString()}</div>`;
            html += '</div>';
            
            statusDiv.innerHTML = html;
        }

        // Load documents list
        async function loadDocuments() {
            const documentsDiv = document.getElementById('documentsList');
            
            try {
                const response = await fetch(`${API_BASE}/api/v1/documents`);
                
                if (response.ok) {
                    const result = await response.json();
                    displayDocuments(result.documents);
                } else {
                    documentsDiv.innerHTML = '<div class="status error">Error loading documents</div>';
                }
            } catch (error) {
                documentsDiv.innerHTML = '<div class="status error">Error loading documents</div>';
            }
        }

        // Display documents
        function displayDocuments(documents) {
            const documentsDiv = document.getElementById('documentsList');
            const countSpan = document.getElementById('documentCount');
            
            // Update document count
            countSpan.textContent = `${documents.length} document${documents.length !== 1 ? 's' : ''}`;
            
            if (documents.length === 0) {
                documentsDiv.innerHTML = '<div class="status">No documents uploaded yet. Upload some documents to get started!</div>';
                return;
            }

            let html = '<div class="documents-list">';
            documents.forEach(doc => {
                const fileSize = doc.file_size || doc.size || 0;
                const status = doc.status || 'processed';
                const statusClass = status === 'processed' ? 'status-processed' : 
                                  status === 'processing' ? 'status-processing' : 'status-error';
                
                html += `
                    <div class="document-item" id="doc-${doc.id}">
                        <div class="document-info">
                            <div class="document-name">üìÑ ${doc.filename}
                                <span class="document-status ${statusClass}">${status}</span>
                            </div>
                            <div class="document-details">
                                Size: ${formatFileSize(fileSize)} | 
                                Chunks: ${doc.chunks_count || 0} | 
                                Uploaded: ${formatDate(doc.upload_date)}
                            </div>
                        </div>
                        <button class="delete-btn" onclick="deleteDoc(${doc.id})" title="Delete document">
                            <i class="fas fa-trash"></i>
                        </button>
                    </div>
                `;
            });
            html += '</div>';
            documentsDiv.innerHTML = html;
        }

        // Delete document - WORKING VERSION
        function deleteDoc(docId) {
            if (!confirm('Are you sure you want to delete this document? This will also remove all associated data.')) {
                return;
            }
            
            const docElement = document.getElementById(`doc-${docId}`);
            if (docElement) {
                docElement.classList.add('deleting');
            }
            
            showStatus('Deleting document...', 'info');
            
            fetch(`${API_BASE}/api/v1/documents/${docId}`, { method: 'DELETE' })
                .then(response => response.json())
                .then(result => {
                    if (result.message) {
                        showStatus(`‚úì ${result.message}`, 'success');
                        
                        // Remove with animation
                        if (docElement) {
                            docElement.style.transition = 'all 0.3s ease';
                            docElement.style.transform = 'translateX(-100%)';
                            docElement.style.opacity = '0';
                            setTimeout(() => {
                                loadDocuments();
                            }, 300);
                        } else {
                            loadDocuments();
                        }
                    } else {
                        showStatus('‚úó Delete failed', 'error');
                        if (docElement) {
                            docElement.classList.remove('deleting');
                        }
                    }
                })
                .catch(error => {
                    showStatus(`‚úó Error deleting document: ${error.message}`, 'error');
                    if (docElement) {
                        docElement.classList.remove('deleting');
                    }
                });
        }

        // Delete all documents
        async function deleteAllDocuments() {
            try {
                // First, get the current documents to check if any exist
                const response = await fetch(`${API_BASE}/api/v1/documents`);
                const result = await response.json();
                
                if (!response.ok) {
                    showStatus('Error loading documents', 'error');
                    return;
                }
                
                const documents = result.documents || [];
                
                if (documents.length === 0) {
                    showStatus('No documents to delete', 'info');
                    return;
                }
                
                // Show confirmation dialog
                const confirmMessage = `Are you sure you want to delete ALL ${documents.length} documents? This action cannot be undone and will remove all associated data.`;
                if (!confirm(confirmMessage)) {
                    return;
                }
                
                // Disable the delete all button during operation
                const deleteAllBtn = document.querySelector('.delete-all-btn');
                deleteAllBtn.disabled = true;
                deleteAllBtn.innerHTML = '<span class="spinner"></span> Deleting...';
                
                showStatus(`Deleting ${documents.length} documents...`, 'info');
                
                let successCount = 0;
                let errorCount = 0;
                
                // Delete each document
                for (const doc of documents) {
                    try {
                        const deleteResponse = await fetch(`${API_BASE}/api/v1/documents/${doc.id}`, {
                            method: 'DELETE'
                        });
                        
                        if (deleteResponse.ok) {
                            successCount++;
                            showStatus(`Deleted ${successCount}/${documents.length} documents...`, 'info');
                        } else {
                            errorCount++;
                        }
                    } catch (error) {
                        errorCount++;
                        console.error(`Error deleting document ${doc.id}:`, error);
                    }
                }
                
                // Show final result
                if (errorCount === 0) {
                    showStatus(`‚úì Successfully deleted all ${successCount} documents`, 'success');
                } else {
                    showStatus(`‚ö†Ô∏è Deleted ${successCount} documents, ${errorCount} failed`, 'error');
                }
                
                // Refresh the documents list
                await loadDocuments();
                
            } catch (error) {
                showStatus(`‚úó Error deleting documents: ${error.message}`, 'error');
            } finally {
                // Re-enable the delete all button
                const deleteAllBtn = document.querySelector('.delete-all-btn');
                deleteAllBtn.disabled = false;
                deleteAllBtn.innerHTML = 'üóëÔ∏è Delete All';
            }
        }

        // Helper functions
        function showStatus(message, type) {
            const statusDiv = document.getElementById('uploadStatus');
            statusDiv.innerHTML = `<div class="status ${type}">${message}</div>`;
        }

        function showSearchResults(message, type) {
            const resultsDiv = document.getElementById('searchResults');
            resultsDiv.innerHTML = `<div class="status ${type}">${message}</div>`;
        }

        function handleSearchKeyPress(event) {
            if (event.key === 'Enter') {
                searchDocuments();
            }
        }

        // Refresh documents list
        function refreshDocuments() {
            const refreshBtn = document.querySelector('.refresh-btn');
            refreshBtn.disabled = true;
            refreshBtn.innerHTML = '<span class="spinner"></span> Refreshing...';
            
            loadDocuments().finally(() => {
                refreshBtn.disabled = false;
                refreshBtn.innerHTML = 'üîÑ Refresh';
            });
        }
        
        // Format file size
        function formatFileSize(bytes) {
            if (!bytes || bytes === 0) return '0 KB';
            const sizes = ['B', 'KB', 'MB', 'GB'];
            const i = Math.floor(Math.log(bytes) / Math.log(1024));
            return `${(bytes / Math.pow(1024, i)).toFixed(1)} ${sizes[i]}`;
        }
        
        // Format date
        function formatDate(dateStr) {
            if (!dateStr || dateStr === 'unknown') return 'Unknown';
            try {
                const date = new Date(dateStr);
                if (isNaN(date.getTime())) return dateStr;
                
                const today = new Date();
                const diffTime = today - date;
                const diffDays = Math.floor(diffTime / (1000 * 60 * 60 * 24));
                
                if (diffDays === 0) {
                    return 'Today ' + date.toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' });
                } else if (diffDays === 1) {
                    return 'Yesterday';
                } else if (diffDays < 7) {
                    return `${diffDays} days ago`;
                } else {
                    return date.toLocaleDateString();
                }
            } catch (e) {
                return dateStr;
            }
        }
        
        // Load documents with better error handling
        async function loadDocuments() {
            const documentsDiv = document.getElementById('documentsList');
            const storageInfoDiv = document.getElementById('storageInfo');
            
            documentsDiv.innerHTML = '<div class="loading"><span class="spinner"></span>Loading documents...</div>';
            
            try {
                const response = await fetch(`${API_BASE}/api/v1/documents`);
                const result = await response.json();
                
                if (response.ok) {
                    // Show storage info if available
                    if (result.message) {
                        storageInfoDiv.style.display = 'block';
                        storageInfoDiv.innerHTML = `<span class="storage-type">Storage:</span> ${result.message}`;
                    } else {
                        storageInfoDiv.style.display = 'none';
                    }
                    
                    displayDocuments(result.documents);
                } else {
                    documentsDiv.innerHTML = `<div class="status error">Error loading documents: ${result.detail || 'Unknown error'}</div>`;
                }
            } catch (error) {
                documentsDiv.innerHTML = `<div class="status error">Failed to load documents: ${error.message}</div>`;
            }
        }
        
        // LLM Control Functions
        async function preloadLLM() {
            try {
                const response = await fetch(`${API_BASE}/api/v1/llm/preload`, {
                    method: 'POST'
                });
                
                const result = await response.json();
                
                if (result.success) {
                    showStatus(`‚úÖ Model preloaded in ${result.preload_time}s`, 'success');
                } else {
                    showStatus(`‚ùå Preload failed: ${result.message}`, 'error');
                }
            } catch (error) {
                showStatus(`‚ùå Preload error: ${error.message}`, 'error');
            }
        }
        
        async function reconnectLLM() {
            try {
                const response = await fetch(`${API_BASE}/api/v1/llm/reconnect`, {
                    method: 'POST'
                });
                
                const result = await response.json();
                
                if (result.available) {
                    showStatus(`‚úÖ LLM reconnected: ${result.model}`, 'success');
                    checkSystemStatus(); // Refresh status
                } else {
                    showStatus(`‚ùå Reconnect failed: ${result.message}`, 'error');
                }
            } catch (error) {
                showStatus(`‚ùå Reconnect error: ${error.message}`, 'error');
            }
        }
        
        async function reloadLLMConfig() {
            try {
                showStatus('üîÑ Reloading LLM configuration...', 'info');
                
                const response = await fetch(`${API_BASE}/api/v1/llm/reload-config`, {
                    method: 'POST'
                });
                
                const result = await response.json();
                
                if (result.success) {
                    showStatus(`‚úÖ Configuration reloaded: ${result.model}`, 'success');
                    checkSystemStatus(); // Refresh status
                } else {
                    showStatus(`‚ùå Config reload failed: ${result.message}`, 'error');
                    if (result.suggestion) {
                        showStatus(`üí° Suggestion: ${result.suggestion}`, 'info');
                    }
                }
            } catch (error) {
                showStatus(`‚ùå Config reload error: ${error.message}`, 'error');
            }
        }
        
        async function showModelSelector() {
            try {
                const response = await fetch(`${API_BASE}/api/v1/llm/models`);
                const result = await response.json();
                
                if (result.available) {
                    const models = result.models;
                    const currentModel = result.current_model;
                    
                    let modalHTML = `
                        <div style="position: fixed; top: 0; left: 0; right: 0; bottom: 0; background: rgba(0,0,0,0.5); z-index: 1000; display: flex; justify-content: center; align-items: center;" id="modelModal">
                            <div style="background: white; padding: 20px; border-radius: 8px; max-width: 500px; width: 90%;">
                                <h3 style="margin: 0 0 15px 0;">ü§ñ Select LLM Model</h3>
                                <p style="margin: 0 0 15px 0; color: #666;">Current: <strong>${currentModel}</strong></p>
                                <div style="max-height: 300px; overflow-y: auto;">
                    `;
                    
                    Object.entries(models).forEach(([key, model]) => {
                        const isSelected = key === currentModel;
                        modalHTML += `
                            <div style="border: 1px solid #ddd; padding: 10px; margin: 5px 0; border-radius: 4px; cursor: pointer; background: ${isSelected ? '#e8f4f8' : 'white'};" onclick="switchModel('${key}')">
                                <div style="font-weight: bold;">${model.name}</div>
                                <div style="font-size: 12px; color: #666;">${model.description}</div>
                                <div style="font-size: 11px; color: #999;">Max tokens: ${model.max_tokens} | Context: ${model.context_length}</div>
                            </div>
                        `;
                    });
                    
                    modalHTML += `
                                </div>
                                <div style="margin-top: 15px; text-align: right;">
                                    <button onclick="closeModelModal()" style="background: #6c757d; color: white; border: none; padding: 8px 16px; border-radius: 4px; cursor: pointer;">Cancel</button>
                                </div>
                            </div>
                        </div>
                    `;
                    
                    document.body.insertAdjacentHTML('beforeend', modalHTML);
                } else {
                    showStatus(`‚ùå Could not load models: ${result.error}`, 'error');
                }
            } catch (error) {
                showStatus(`‚ùå Error loading models: ${error.message}`, 'error');
            }
        }
        
        async function switchModel(modelKey) {
            try {
                showStatus('üîÑ Switching model...', 'info');
                
                const response = await fetch(`${API_BASE}/api/v1/llm/switch`, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({ model: modelKey })
                });
                
                const result = await response.json();
                
                if (result.success) {
                    showStatus(`‚úÖ Switched to ${result.new_model}`, 'success');
                    
                    // Force reconnect to refresh everything
                    setTimeout(async () => {
                        await reconnectLLM();
                        checkSystemStatus(); // Refresh status
                    }, 1000);
                } else {
                    showStatus(`‚ùå Switch failed: ${result.message}`, 'error');
                    if (result.suggestion) {
                        showStatus(`üí° Suggestion: ${result.suggestion}`, 'info');
                    }
                }
                
                closeModelModal();
            } catch (error) {
                showStatus(`‚ùå Switch error: ${error.message}`, 'error');
                closeModelModal();
            }
        }
        
        function closeModelModal() {
            const modal = document.getElementById('modelModal');
            if (modal) {
                modal.remove();
            }
        }
        
        // Load documents on page load
        document.addEventListener('DOMContentLoaded', function() {
            loadDocuments();
            checkSystemStatus(); // Auto-check system status on load
            
            // Auto-refresh documents every 30 seconds if page is visible
            setInterval(() => {
                if (!document.hidden) {
                    loadDocuments();
                }
            }, 30000);
        });
    </script>
</body>
</html>